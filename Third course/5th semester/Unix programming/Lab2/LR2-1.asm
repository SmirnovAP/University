.386P				;Разрешение трансляции всех команд Pentium

;Структура для описания дескрипторов сегментов
descr	struc				;Начало объявления структуры
		lim		dw 0		;Граница (биты 0...15)
		base_l	dw 0		;База, биты 0...15
		base_m	db 0		;База, биты 1..23
		attr_1	db 0		;Байт атрибутов 1
		attr_2	db 0		;Граница (биты 16...19) и атрибуты 2
		base_h	db 0		;База, биты 24...31
descr	ends				;Конец объявления структуры

;Сегмент данных
data	segment use16								;16-разрядный сегмент
; Глобальная таблица дескрипторов GDT
gdt_null	descr <0, 0, 0, 0, 0, 0>				;Селектор 0, нулевой дескриптор
gdt_data	descr <data_size - 1, 0, 0, 92h, 0, 0>	;Селектор 8, сегмент данных
gdt_code	descr <code_size - 1, 0, 0, 98h, 0, 0>	;Селектор 16, сегмент команд
gdt_stack	descr <255, 0, 0, 92h, 0, 0>			;Селектор 24 сегмент стека
gdt_screen	descr <3999, 8000h, 0Bh, 92h, 0, 0>		;Селектор 32, видеопамять
gdt_size=$-gdt_null									;Размер GDT
;Различные данные программы
pdescr	df 0										;Псевдодескриптор для команды lgdt
sym		db 1										;Символ для вывода на экран
attr	db 1Eh										;Его атрибут
msg		db 27,'[31;42m  Returned to real mode!   ',27,'[0m$'
msg2	db 27, 'Computer in protected mode', 27, ‘$’
data_size=$-gdt_null								;Размер сегманта данных
data	ends

;Сегмент команд
text	segment use16						;16-разрядный сегмент
		assume CS:text,DS:data
main	proc
		xor		EAX, EAX					;Очистим EAX
		mov		AX, data					;Загрузим в DS сегментный
		mov		DS, AX						;адрес сегмента данных
;Вычислим 32-битовый линейный адрес сегмента данных и загрузим его
;в дескриптор сегмента данных в глобыльно таблице дескрипторов GDT
		shl		EAX, 4						;EAX=линейный базовый адрес
		mov		EBP, EAX					;Сохраним его в EBP для ьудущего
		mov		BX, offset gdt_data			;BX=смещение дескриптора
		mov		[BX].base_l,AX				;Загрузим младшую часть базы
		shr		EAX, 16						;Старшую половину EAX в AX
		mov		[BX].base_m, AL				;Загрузим среднюю часть базы
;Вычислим и загрузим в GDT линейный адрес сегмента команд
		xor		EAX, EAX					;Очистим EAX
		mov		AX, CS						;Сегментный адрес сегмента команд
		shl		EAX, 4
		mov		BX, offset gdt_code
		mov		[BX].base_l,AX
		shr		EAX, 16
		mov		[BX].base_m,AL
;Вычислим и загрузим в GDT линейный адрес сегмента стека
		xor		EAX, EAX					;Очистим EAX
		mov		AX, SS						;Сегментный адрес сегмента стека
		shl		EAX, 4
		mov		BX, offset gdt_stack
		mov		[BX].base_l, AX
		shr		EAX, 16
		mov		[BX].base_m, AL
;Подготовим псевдодескриптор pdescr и загрузим регистр GDTR
		mov		dword ptr pdescr+2, EBP		;База GDT
		mov		word ptr pdescr, gdt_size-1	;Границы GDT
		lgdt	pdescr						;Загрузим регистр GDTR

		cli									;Запрет аппаратных прерываний
;Переходим в защищённый режим
		mov		EAX, CR0					;Получим содержимое регистра CR0
		or		EAX, 1						;Установим бит защищённого режима
		mov		CR0, EAX					;Запишем назад в CR0
;-----------------------------------------------;
; Теперь процессор работает в защищённом режиме ;
;-----------------------------------------------;
;Загружаем в CS:IP селектор:смещение точки continue
		db		0EAh						;Код команды far jmp
		dw		offset continue				;Смещение
		dw		16							;Селектор сегмента команд
continue:
;Делаем адресуемые данные
		mov		AX,8						;Селектор сегмента данных
		mov		DS,AX
;Делаем адресуемый стек
		mov		AX,24						;Селектор сегмента стека
		mov		SS,AX
;Инициализируем ES
		mov		AX,32						;Селектор сегмента видеобуфера
		mov		ES,AX						;Инициализируем ES
;Вывод сообщения в видеопамять
		mov		DI,160
		mov		SI, offset msg2
		mov		AH, attr						; Установка цвета текста и фона
scrn:	mov		AL, byte ptr [SI]
		stosw
		inc		SI
		cmp		AL, ‘$’
		jne		scrn
;Вернёмся в реальный режим
;Сформируем и загрузим дескриптора для реального режима
		mov		gdt_data.lim, 0FFFFh		;Граница сегмента данных
		mov		gdt_code.lim, 0FFFFh		;Граница сегмента команд
		mov		gdt_stack.lim, 0FFFFh		;Граница сегмента стека
		mov		gdt_screen.lim, 0FFFFh		;Граница доп. сегмента
		push	DS							;Загрузим теневой регистр
		pop		DS							;сегмента данных
		push	SS							;Загрузим теневой регистр
		pop		SS							;сегмента стека
		push	ES							;Загрузим теневой регистр
		pop		ES							;дополнительного сегмента данных
;Выполним дальний переход для того, чтобы заново загрузить селектор
;в регистр CS и модифицировать его теневой регистр
		db		0EAh						;Командой дальнего перехода
		dw		offset go					;загрузим теневой регистр
		dw		16							;сегмента команд
;Переключим режим процессора
go:		mov		EAX, CR0					;Получим содержимое регистра CR0
		and		EAX, 0FFFFFFFEh				;Сбросим бит защищ1нного режима
		mov		CR0, EAX					;Запишем назад в CR0
		db		0EAh						;Код команды far jmp
		dw		offset return				;Смещение
		dw		text						;Сегмент
;---------------------------------------------------;
; Теперь процессор снова работает в реальном режиме ;
;---------------------------------------------------;
return:
;Восстановим вычислительную среду реального режима
		mov		AX, data					;Сделаем адресуемыми данные
		mov		DS, AX
		mov		AX, stk						;Сделаем адресуемым стек
		mov		SS, AX
		sti									;Разрешим аппаратные прерывания
;Работаем в DOS
		mov		AH,09h						;Проверим выполнение функций DOS
		mov		DX,offset msg				;после возврата в реальный режим
		int		21h
		mov		AX,4C00h					;Завершим программу обычным образом
		int		21h
main	endp
code_size=$-main							;Размер сегмента команд
text	ends

;Сегмент стека
stk		segment stack use16;				;16-разрядный сегмент
		db 256 dup ('^')
stk		ends
		end main